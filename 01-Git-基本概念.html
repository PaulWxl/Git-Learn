<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 第1章Git操作版本控制什么是版本控制？我们为什么要关心它呢？版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统为什么要使用版本控制?软件开发中采用版本控制系统是个明智的选择。有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态。就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。
    
    Git 分布式。 Svn 集中式。 都是 版本 控制 器。Svn 已经 被 淘汰了。 



    集中化的版本控制系统 集中化的版本控制系统诸如CVS，svn以及Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法 这种做法带来了许多好处，现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统; 要远比在各个客户端上维护本地数据库来得轻松容易。 事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同。


    并不是说服务器故障了就没有办法写代码了,只是在服务器故障的情况下,编写的代码是没有办法得到保障的.试想svn中央服务器挂机一天.你还拼命写了一天代码,其中12点之前的代码都是高质量可靠的,而且有很多闪光点.而12点之后的代码由于你想尝试一个比较大胆的想法,将代码改的面目全非了.这样下来你12点之前做的工作也都白费了有记录的版本只能是svn服务器挂掉时保存的版本!)要是中央服务器的磁盘发生故障，碰巧没做备份，或者备份不够及时，就会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，而被客户端偶然提取出来的保存在本地的某些快照数据就成了恢复数据的希望。但这样的话依然是个问题，你不能保证所有的数据都已经有人事先完整提取出来过。只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。




    分布式的版本控制系统 于是分布式版本控制系统问世了。在这类系统中，像Git，BitKeeper等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可以在同一个项目中分别和不同工作小组的人相互协作。分布式的版本控制系统在管理项目时存放的不是项目版本与版本之间的差异.它存的是索引(所需磁盘空间很少所以每个客户端都可以放下整个项目的历史记录)分布式的版本控制系统出现之后,解决了集中式版本控制系统的缺陷:1.断网的情况下也可以进行开发(因为版本控制是在本地进行的)2.使用github进行团队协作,哪怕github挂了每个客户端保存的也都是整个完整的项目(包含历史记录的!!!)



    Git 有 压缩算法 ， 让 所有的 客户端 都作为 服务器， 存储 项目的 整个 历史记录， 由于 使用了 压缩算法， 所以 占据的 磁盘 容量 其实 比较小， 但是 每个 客户端 都有 历史记录。 解决了 集中化版本控制器 单一的 服务器 的 问题。  哪怕是 分布式的， 一般 也是 会有 一个 服务器的。 （相当于 客户端 使用。 ） 

    最重要的是 历史记录。回不到 以前的 代码。服务器 宕机 最主要的 就是 导致 不能 回滚 到 之前的 代码 状态。 任何 一个 版本控制器 看重的 都是 历史记录。 而不是 当前 最新的 版本。 最新的 版本 客户端 自己 手里 都有。 
-->
</body>
</html>